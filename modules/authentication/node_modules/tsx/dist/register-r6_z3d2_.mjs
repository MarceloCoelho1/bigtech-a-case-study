var C=Object.defineProperty;var a=(e,s)=>C(e,"name",{value:s,configurable:!0});import{r as I}from"./get-pipe-path-BHW2eJdv.mjs";import u from"node:module";import d from"node:path";import{fileURLToPath as S}from"node:url";import{parseTsconfig as J,getTsconfig as Q,createFilesMatcher as k,createPathsMatcher as z}from"get-tsconfig";import B from"node:fs";import{b as G,i as H,a as X}from"./index-BQiEz0On.mjs";import{p as M}from"./client-BQVF1NaW.mjs";const x=Object.create(null);x[".js"]=[".ts",".tsx",".js",".jsx"],x[".jsx"]=[".tsx",".ts",".jsx",".js"],x[".cjs"]=[".cts"],x[".mjs"]=[".mts"];const T=a(e=>{const[s,t]=e.split("?"),r=d.extname(s),c=x[r];if(!c)return;const n=s.slice(0,-r.length);return c.map(o=>n+o+(t?`?${t}`:""))},"mapTsExtensions"),K=a(e=>{const s=e.indexOf(":");if(s!==-1)return e.slice(0,s)},"getScheme"),R=a(e=>e[0]==="."&&(e[1]==="/"||e[1]==="."||e[2]==="/"),"isRelativePath"),V=a(e=>R(e)||d.isAbsolute(e),"isUnixPath"),Y=a(e=>{if(V(e))return!0;const s=K(e);return s&&s!=="node"},"requestAcceptsQuery"),U="file://",w=/\.([cm]?ts|[tj]sx)($|\?)/,Z=/\.json($|\?)/,q=/\/(?:$|\?)/,ee=/^(?:@[^/]+\/)?[^/]+$/;let _,g,E=!1;const L=a(e=>{let s=null;if(e){const t=d.resolve(e);s={path:t,config:J(t)}}else{try{s=Q()}catch{}if(!s)return}_=k(s),g=z(s),E=s?.config.compilerOptions?.allowJs??!1},"loadTsconfig"),b=a(e=>Array.from(e).length>0?`?${e.toString()}`:"","urlSearchParamsStringify"),$=[".ts",".tsx",".jsx"],F=a((e,...s)=>{for(const t of $)try{return s[0]+=t,e(...s)}catch{}},"tryExtensions"),se=a(e=>(s,...t)=>{try{return e(s,...t)}catch(r){const c=r;if(c.code==="MODULE_NOT_FOUND"){const n=F(e,s,...t)||F(e,`${s}${d.sep}index`,...t);if(n)return n}throw c}},"createImplicitResolver"),te=`${d.sep}node_modules${d.sep}`,N=a(e=>{if(!e.startsWith("data:text/javascript,"))return;const s=e.indexOf("?");if(s===-1)return;const r=new URLSearchParams(e.slice(s+1)).get("filePath");if(r)return r},"getOriginalFilePath"),A=a(e=>{const s=N(e);return s&&(u._cache[s]=u._cache[e],delete u._cache[e],e=s),e},"interopCjsExports"),j=a((e,s,t)=>{if(!(t?.filename&&w.test(t.filename))&&!E)return;const r=T(s);if(r)for(const c of r)try{return e(c)}catch(n){const{code:o}=n;if(o!=="MODULE_NOT_FOUND"&&o!=="ERR_PACKAGE_PATH_NOT_EXPORTED")throw n}},"resolveTsFilename"),ne=a((e,s,t)=>{if(e.startsWith(U)&&(e=S(e)),g&&!R(e)&&!s?.filename?.includes(te)){const c=g(e);for(const n of c){const o=j(t,n,s);if(o)return o;try{return t(n)}catch{}}}const r=j(t,e,s);if(r)return r;try{return t(e)}catch(c){const n=c;if(n.code==="MODULE_NOT_FOUND"&&typeof n.path=="string"&&n.path.endsWith(`${d.sep}package.json`)){const o=n.message.match(/^Cannot find module '([^']+)'$/);if(o){const p=o[1],f=j(t,p,s);if(f)return f}const i=n.message.match(/^Cannot find module '([^']+)'. Please verify that the package.json has a valid "main" entry$/);if(i){const p=i[1],f=j(t,p,s);if(f)return f}}throw n}},"resolveRequest"),re=a((e,s)=>(s&&(e=se(e)),(t,r,c,n)=>{const o=a(m=>e(m,r,c,n),"resolve");if(t=A(t),r?.filename){const m=N(r.filename);m&&(r.filename=m.split("?")[0])}const i=t.split("?"),p=new URLSearchParams(i[1]);if(r?.filename){const P=new URLSearchParams(r.filename.split("?")[1]).get("namespace");P&&p.append("namespace",P)}if((p.get("namespace")??void 0)!==s)return o(t);let f=ne(i[0],r,o);return d.isAbsolute(f)&&!f.endsWith(".json")&&!f.endsWith(".node")&&(f+=b(p)),f}),"createResolveFilename"),oe=`
//# sourceMappingURL=data:application/json;base64,`,D=a(()=>process.sourceMapsEnabled??!0,"shouldApplySourceMap"),O=a(({code:e,map:s})=>e+oe+Buffer.from(JSON.stringify(s),"utf8").toString("base64"),"inlineSourceMap"),ae=[".cts",".mts",".ts",".tsx",".jsx"],ce=[".js",".cjs",".mjs"],ie=a((e,s)=>{const t=Object.assign(Object.create(null),e),r=t[".js"],c=a((n,o)=>{const[i,p]=o.split("?");if((new URLSearchParams(p).get("namespace")??void 0)!==s)return r(n,i);M?.send&&M.send({type:"dependency",path:i});const m=ae.some(l=>i.endsWith(l)),P=ce.some(l=>i.endsWith(l));if(!m&&!P)return r(n,i);let h=B.readFileSync(i,"utf8");if(i.endsWith(".cjs")){const l=G(o,h);l&&(h=D()?O(l):l.code)}else if(m||H(h)){const l=X(h,o,{tsconfigRaw:_?.(i)});h=D()?O(l):l.code}n._compile(h,i)},"transformer");t[".js"]=c;for(const n of $){const o=Object.getOwnPropertyDescriptor(t,n);Object.defineProperty(t,n,{value:c,enumerable:o?.enumerable||!s})}return Object.defineProperty(t,".mjs",{value:c,enumerable:!1}),t},"createExtensions"),W=a((e,s)=>{if(!s)throw new Error("The current file path (__filename or import.meta.url) must be provided in the second argument of tsx.require()");return(typeof s=="string"&&s.startsWith("file://")||s instanceof URL)&&(s=S(s)),d.resolve(d.dirname(s),e)},"resolveContext"),fe=a(e=>{const{sourceMapsEnabled:s}=process,{_extensions:t,_resolveFilename:r}=u;L(process.env.TSX_TSCONFIG_PATH),process.setSourceMapsEnabled(!0);const c=re(r,e?.namespace);u._resolveFilename=c;const n=ie(u._extensions,e?.namespace);u._extensions=n;const o=a(()=>{s===!1&&process.setSourceMapsEnabled(!1),u._extensions=t,u._resolveFilename=r},"unregister");if(e?.namespace){const i=a((f,m)=>{const P=W(f,m),[h,l]=P.split("?"),y=new URLSearchParams(l);return e.namespace&&y.set("namespace",e.namespace),I(h+b(y))},"scopedRequire");o.require=i;const p=a((f,m,P)=>{const h=W(f,m),[l,y]=h.split("?"),v=new URLSearchParams(y);return e.namespace&&v.set("namespace",e.namespace),c(l+b(v),module,!1,P)},"scopedResolve");o.resolve=p,o.unregister=o}return o},"register");export{Z as a,O as b,Y as c,q as d,ee as e,_ as f,E as g,U as h,A as i,g as j,L as l,T as m,fe as r,w as t};
